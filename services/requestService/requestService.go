// Copyright 2016 Esteban Garro. All rights reserved.

// Package requestService implements the service for the request functionality.
package requestService

import (
  "time"
  "errors"
	"github.com/goinggo/beego-mgo/models/requestModel"
	"github.com/goinggo/beego-mgo/services"
	"github.com/goinggo/beego-mgo/utilities/helper"
	"github.com/goinggo/beego-mgo/utilities/mongo"
	log "github.com/goinggo/tracelog"
	"github.com/kelseyhightower/envconfig"
	"gopkg.in/mgo.v2"
	"gopkg.in/mgo.v2/bson"
)

//** TYPES

type (
	// requestConfiguration contains settings for running the request service.
	requestsConfiguration struct {
		Database   string
		Collection string
	}
)

//** PACKAGE VARIABLES

// Config provides requests configuration from the environment variables via the envconfig package
var Config requestsConfiguration

//** INIT

func init() {
	// Pull in the configuration.
	if err := envconfig.Process("requests", &Config); err != nil {
		log.CompletedError(err, helper.MainGoRoutine, "Init")
	}
}

//** PUBLIC FUNCTIONS

// InsertNewRequest adds a Request object to mongoDB
func InsertNewRequest(service *services.Service, request map[string]interface{}) error {
	log.Startedf(service.UserID, "InsertNewRequest", "request:%+v", request)
  f := func(collection *mgo.Collection) error {
		queryMap := bson.M(request)

		log.Trace(service.UserID, "InsertNewRequest", "MGO : db.%s.insert(%s)", Config.Collection, mongo.ToString(queryMap))
		return collection.Insert(queryMap)
	}

  if err := service.DBAction(Config.Database, Config.Collection, f); err != nil {
		if err != mgo.ErrNotFound {
			log.CompletedError(err, service.UserID, "InsertNewRequest")
			return err
		}
	}

	log.Completedf(service.UserID, "InsertNewRequest", "new request objected successfully injected!")
	return nil
}

// FetchAllRequestsFromDateToDate retrieves the profile of all the requests between startTime and endTime
func FetchAllRequestsFromDateToDate(service *services.Service, startTime time.Time, endTime time.Time) ([]requestModel.Request, error) {
  if endTime.Before(startTime) {
    err := errors.New("FetchAllRequestsFromDateToDate: endTime before stratTime")
    return nil, err
  }
	log.Startedf(service.UserID, "FetchAllRequestsFromDateToDate", "startTime[%s]-endTime[%s]", startTime.String(), endTime.String())

	var requests []requestModel.Request
	f := func(collection *mgo.Collection) error {
		queryMap := bson.M{ "time" : bson.M{ "$gte" : startTime, "$lt" : endTime}}

		log.Trace(service.UserID, "FetchAllRequestsFromDateToDate", "MGO : db.%s.find(%s)", Config.Collection, mongo.ToString(queryMap))
		return collection.Find(queryMap).All(&requests)
	}

	if err := service.DBAction(Config.Database, Config.Collection, f); err != nil {
		if err != mgo.ErrNotFound {
			log.CompletedError(err, service.UserID, "FetchAllRequestsFromDateToDate")
			return nil, err
		}
	}

	log.Completedf(service.UserID, "FetchAllRequestsFromDateToDate", "requests on interval startTime[%s]-endTime[%s]: %+v", startTime.String(), endTime.String(), requests)
	return requests, nil
}

// FetchAllRequestsForUser retrieves the requests generated by or assigned to a user identified by its email
func FetchAllRequestsForUser(service *services.Service, email string, isCG bool) ([]requestModel.Request, error) {
	log.Startedf(service.UserID, "FetchAllRequestsForUser", "email[%s]", email)

	var requests []requestModel.Request
	f := func(collection *mgo.Collection) error {
		queryMap := bson.M{}
    if isCG {
      queryMap["care_giver"] = email
    } else {
      queryMap["originator"] = email
    }

		log.Trace(service.UserID, "FetchAllRequestsForUser", "Query : db.%s.find(%s)", Config.Collection, mongo.ToString(queryMap))
		return collection.Find(queryMap).All(&requests)
	}

	if err := service.DBAction(Config.Database, Config.Collection, f); err != nil {
		log.CompletedError(err, service.UserID, "FetchAllRequestsForUser")
		return nil, err
	}

	log.Completedf(service.UserID, "FetchAllRequestsForUser", "requests related to %s %+v", email, requests)
	return requests, nil
}

//To be used by the DatabaseCheckup Socket Server:
// FetchRequest retrieves a service request object based on ID:
func FetchRequest(service *services.Service, ID bson.ObjectId) (*requestModel.Request, error) {
	log.Startedf(service.UserID, "FetchRequest", "ID[%+v]", ID)

	var request *requestModel.Request
	f := func(collection *mgo.Collection) error {
		queryMap := bson.M{ "_id" : ID}

		log.Trace(service.UserID, "FetchRequest", "MGO : db.%s.find(%s)", Config.Collection, mongo.ToString(queryMap))
		return collection.Find(queryMap).One(&request)
	}

	if err := service.DBAction(Config.Database, Config.Collection, f); err != nil {
		if err != mgo.ErrNotFound {
			log.CompletedError(err, service.UserID, "FetchRequest")
			return nil, err
		}
	}

	log.Completedf(service.UserID, "FetchRequest", "Request found: %+v", request)
	return request, nil
}
